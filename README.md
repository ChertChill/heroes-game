# Итоговый проект "Реализация ключевых механик игры" (Магистратура МИФИ + Skillfactory)

## Описание

Имплементация интерфейсов библиотеки heroes_task_lib для симуляции армии противника в стратегии в стиле игры "Герои Меча и Магии 3".

Эти интерфейсы - GeneratePreset, SimulateBattle, SuitableForAttackUnitsFinder и UnitTargetPathFinder.

## Реализованные методы

### generate (интерфейс GeneratePreset)

Метод для формирования пресета армии компьютера, т.е. такого набора юнитов разного типа, который был бы максимально эффективен в первую очередь по соотношению атаки к стоимостии соотношению здоровья к стоимости. При этом соблюдается ограничение в 11 юнитов каждого типа. 

**Цель метода** — создать армию компьютера.

**Расчет и доказательство алгоритмической сложности метода:**
1. Сортировка списка юнитов:

   - Метод sortUnitsByEfficiency сортирует unitList с помощью Comparator.
   - Сложность сортировки: O(n * log n), где n — количество юнитов в списке (размер списка unitList).
3. Основной цикл по юнитам:

   - Данный цикл перебирает каждый юнит в списке unitList через метод addUnitsToArmy.
   - Его сложность — O(n), где n — размер unitList.
5. Метод addUnitsToArmy:

   - Цикл внутри выполняется до MAX_UNIT_COUNT раз — O(MAX_UNIT_COUNT).
   - Каждая итерация вызывает:
     * generateUniqueCoordinate — в худшем случае координата генерируется за O(WIDTH * HEIGHT), хотя на практике он завершается быстрее благодаря равномерному распределению координат.
     * cloneUnitWithNewCoordinate — создает нового юнита (создание объекта и копирование нескольких карт бонусов) за O(k), где k — фиксированное число элементов бонусов (константная сложность — O(1)).

**Общая сложность:**
- Сортировка — O(n * log n).
- Основной цикл для каждого юнита (до n раз):
  * addUnitsToArmy — внутренний цикл выполняется O(MAX_UNIT_COUNT) раз.
  * generateUniqueCoordinate — O(WIDTH * HEIGHT), но практически меньше.
  * cloneUnitWithNewCoordinate — константная сложность, за O(1).

**Итого:**
O(n * log n) + O(n * MAX_UNIT_COUNT * (WIDTH * HEIGHT)), где MAX_UNIT_COUNT, WIDTH и HEIGHT являются константами.
Можно упростить до O(n * log n + n) -> O(n * log n).

### simulate (интерфейс SimulateBattle)

Метод осуществляет симуляцию боя между армией игрока и армией компьютера.

**Цель метода** — провести бой, следуя установленным правилам.

**Расчет и доказательство алгоритмической сложности метода:**
1. Инициализация списка юнитов

   - Метод initActiveUnits фильтрует юнитов с помощью stream().filter() со сложностью — O(n), где n — количество юнитов в армии.
   - Сортировка по убыванию атаки с помощью sorted() со сложностью — O(n * log n).
   - Итого: для одной армии сложность этой операции будет — O(n log n), а для обеих армий — 2 * O(n log n) -> O(n log n).
3. Основной цикл симуляции:

   - Данный цикл работает, пока есть живые юниты в обеих армиях.
   - В каждом раунде симуляции:
     * Перебираем каждого юнита для выполнения атаки — O(n), так как должны быть проверены все юниты в обеих армиях.
     * Выполняем атаку для каждого юнита — O(1), по условию.
   - Удаляем мертвых юнитов с помощью метода removeIf() со сложностью O(n), так как этот метод проверяет каждого юнита.
   - Итого: в одном раунде для обеих армий суммарная сложность — O(n), так как проходим по каждому юниту один раз и удаляем мертвых юнитов.
3. Количество раундов:

   - Основной цикл продолжается до тех пор, пока хотя бы одна армия не останется без живых юнитов.
   - В худшем случае армия может потерять юнитов по одному за каждый раунд.
   - Итого: цикл может быть выполнен до n раз — O(n), где n — количество юнитов в армии.

**Общая сложность:**
- Инициализация — O(n * log n).
- Основной цикл — O(n) за каждый раунд. В худшем случае количество раундов — O(n).
- Удаление мертвых юнитов — O(n) за каждый раунд.

**Итого:**
Для n раундов сложность — O(n^2).

Учитывая инициализацию сложность — O(n * log n + n^2) -> O (n^2).

### getSuitableUnits (интерфейс SuitableForAttackUnitsFinder)

Метод определяет список юнитов, подходящих для атаки, для атакующего юнита одной из армий.

**Цель метода** — исключить ненужные попытки найти кратчайший путь между юнитами, которые не могут атаковать друг друга.

**Расчет и доказательство алгоритмической сложности метода:**
1. Основной цикл по рядам юнитов:
   - Выполняется итерация по m рядам.
   - Для каждого ряда вызывается findLeftMostAliveUnit/findRightMostAliveUnit со сложностью O(n).
   - Итого: сложность цикла — O(m * n).
2. Определение списка юнитов, подходящих для атаки:
   - В методах findLeftMostAliveUnit/findRightMostAliveUnit цикл проходит по каждому юниту в ряду (всего n) со сложностью — O(n).
   - Условие и операции внутри цикла имеют константную сложность — O(1).
   - Итого: сложность методов для каждого ряда — O(n).

**Общая сложность:**
- Основной цикл — O(m * n).
- Определение списка юнитов, подходящих для атаки — O(n).

**Итого:**
Метод getSuitableUnits вызывает один из методов findLeftMostAliveUnit/findRightMostAliveUnit для каждого ряда (всего m).

Таким образом, общая сложность — O(m * n), но при фиксированном m (равно 3), фактическая сложность — O(n), где n — количество юнитов в одном ряду.

### getTargetPath (интерфейс UnitTargetPathFinder)

Метод определяет кратчайший маршрут между атакующим и атакуемым юнитом и возвращает его в виде списка объектов, содержащих координаты каждой точки данного кратчайшего пути.

**Цель метода** — найти кратчайший путь между атакующим и атакуемым юнитом.

**Расчет и доказательство алгоритмической сложности метода:**
1. Определение области поиска:

   - Определяются min/max границы области на основе позиций юнитов с учетом заданного размера области.
   - Итого: O(1), поскольку расчет границ поля происходит с использованием базовых операций и сравнения..
2. Создание матрицы занятых клеток:

   - Метод getOccupiedMatrix работает со сложностью — O(n), где n — количество юнитов в списке existingUnitList.
   - Для каждого юнита проводится проверка на активность — тогда его позиция помечается как занятая.
   - Итого: O(n), где n — количество юнитов в списке.
3. Основной цикл поиска пути по A* и JPS:

   - Метод aStarWithJPS является решающим при расчете сложности.
   - Используется приоритетная очередь, которая будет содержать возможные узлы для обработки и организована по стоимости пути с учетом эвристики.
   - При каждом шаге извлекается узел с минимальной стоимостью и для него вычисляются соседние узлы, используя Jump Point Search.
   - JPS активно сокращает количество соседей, что снижает сложность по сравнению с обычным поиском в ширину.
   - Основной цикл выполняется до тех пор, пока не будет найден путь или пока очередь не опустеет.
   - Итого:
     * В худшем случае, метод aStarWithJPS будет обрабатывать каждый возможный узел. Это количество узлов зависит от площади поля, которая в нашем случае ограничена размерами WIDTH и HEIGHT. Размер поля = WIDTH * HEIGHT.
     * Поиск пути в стандартном A* без JPS — это O(W * H), где W — ширина, а H — высота поля.
     * Применение JPS сокращает количество исследуемых соседей, особенно при обработке длинных прямых путей, что снижает константу. Однако в худшем случае его сложность все равно будет зависеть от числа возможных узлов и связана с количеством возможных прямых, которые необходимо будет проверить для каждого узла, и аналогично оценить в O(W * H).
4. Построение пути:

   - После нахождения пути происходит его восстановление путем обратного прохода через хеш-карту предшественников.
   - Итого: этот процесс осуществляет метод constructPath — просто обход цепочки узлов, и его сложность составляет O(P), где P — количество шагов в пути (обычно гораздо меньше числа возможных узлов).

**Общая сложность:**
- Определение области поиска — O(1).
- Получение матрицы занятых клеток — O(n).
- Поиск пути по A* и JPS — O(WIDTH * HEIGHT).
- Построение пути — O(P).

**Итого:**
В худшем случае общая сложность — O(W * H), так как поиск пути доминирует, и число клеток (W * H) обычно больше, чем количество юнитов (N) и шагов в пути (P).

## Использование

**1. Требования:**

* Java 20 и старше
* IDE (например, IntelliJ IDEA)

**2. Склонировать репозиторий и перейти в каталог проекта:**

```sh
git clone https://github.com/ChertChill/heroes-game.git
cd heroes-game
```
